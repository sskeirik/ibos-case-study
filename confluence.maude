---- author: Francisco Duran (primary author)
---  author: Stephen Skeirik (removed unneeded dependencies)
---- last modified by Stpehen Skeirik on August 6th, 2019


fmod CONFLUENCE-AUX is
  pr UNIT-FM .
  pr STMT-EXTRA .
  pr TERM-EXTRA .

  var T T' : Term .
  var TL TL' : TermList .
  var Tp Tp' Tp'' Tp''' : Type .
  var TpL TpL' : TypeList .
  var M M' M'' : Module .
  var At : Attr .
  var AtS : AttrSet .
  var QI L F G : Qid .
  var QIL : QidList .
  var ODS : OpDeclSet .
  var Eq : Equation .
  var EqS : EquationSet .
  var Cd : Condition .
  var S : Sort .
  var N : Nat .
  var Id : String .
  var V W : Variable .
  var C : Constant .
  var Subst : Substitution .

  op name : Qid Nat -> String .
  op name : String Nat -> String .
  eq name(QI, N) = string(QI) + string(N, 10) .
  eq name(Id, N) = Id + string(N, 10) .

  op sameKind : Module TypeList TypeList ~> Bool [ditto] .
  eq sameKind(M, (Tp Tp' TpL), (Tp'' Tp''' TpL'))
    = sameKind(M, Tp, Tp'') and-then sameKind(M, Tp' TpL, Tp''' TpL') .
  eq sameKind(M, nil, nil) = true .
  eq sameKind(M, TpL, TpL') = false [owise] .

  op getLabel : AttrSet -> Qid .
  eq getLabel(label(L) AtS) = L .
  eq getLabel(AtS) = 'no-label [owise] .

  op metaMatch : Module EquationSet ~> Bool .
  eq metaMatch(M, eq T = T' [none] . EqS)
    = metaMatch(M, T, T', nil, 0) =/= noMatch and-then metaMatch(M, EqS) .
  eq metaMatch(M, none) = true .

  op substitute : Module Term Substitution -> Term .
  op substitute : Module TermList Substitution -> TermList .

  eq substitute(M, T, none) = T .
  eq substitute(M, V, ((W <- T) ; Subst))
    = if getName(V) == getName(W) and-then sameKind(M, getType(V), getType(W))
      then T
      else substitute(M, V, Subst)
      fi .
  eq substitute(M, C, ((W <- T); Subst)) = C .
  eq substitute(M, F[TL], Subst) = F[substitute(M, TL, Subst)] .
  eq substitute(M, (T, TL), Subst)
    = (substitute(M, T, Subst), substitute(M, TL, Subst)) .

  op dropEqs : Nat EquationSet -> EquationSet .
  eq dropEqs(s(N),Eq EqS) = dropEqs(N,EqS) .
  eq dropEqs(s(N),none) = none .
  eq dropEqs(0,EqS) = EqS .

  op pickEq : Nat EquationSet -> EquationSet .
  eq pickEq(s(N),Eq EqS) = pickEq(N,EqS) .
  eq pickEq(s(N),none) = none .
  eq pickEq(0,Eq EqS) = Eq .
endfm

fmod CC-CRITICAL-PAIR is
  pr TERM-EXTRA .
  pr STRING .

  sort CritPair .
  ---- Each of the critical pairs can be in one of the following states:
  ---- - pending: it remains as a proof obligation
  ---- - non-maximal: there is another cp more general than it
  ---- - joined: after simplifying both terms they are equal
  ---- - unfeasible: the condition of the cp is unfeasible (see WRLA'10 paper)
  ---- - context-joinable: the cp is joinable when considering the context
  ----   provided by the condition of the cp (see WRLA'10 paper)
  ---- - proved: discharged by the ITP
  sort CPStatus .
  ops pending non-maximal joined unfeasible context-joinable proved : -> CPStatus .
  ---- Each critical pair is represented as a 6/7-tuple with the following components:
  ---- - A string that represents the id of the cp, given by the CRC
  ----   (currently it results from the concatenation of the name of the module and an index)
  ---- - The qids of the equations that generated the cp ('no-label if the eq has no label)
  ---- - The terms defining the cp
  ---- - The condition is included only if at least one of the equations that generated the
  ----   cp was conditional
  ---- - The cp status (initially pending, changed to one of the other possible states when discarded)
  op cp : String Qid Qid Term Term CPStatus -> CritPair .
  op ccp : String Qid Qid Term Term Condition CPStatus -> CritPair .

  var S : String .
  vars T T' U V : Term .
  vars L L' : Qid .
  var  Cd Cd' : Condition .
  var  CPSt : CPStatus .

  op cp : Qid Qid Term Term CPStatus -> CritPair .
  op ccp : Qid Qid Term Term Condition CPStatus -> CritPair .

  ops lhs rhs : CritPair -> Term .
  eq lhs(cp(L, L', T, T', CPSt)) = T .
  eq lhs(ccp(L, L', T, T', Cd, CPSt)) = T .
  eq lhs(cp(S, L, L', T, T', CPSt)) = T .
  eq lhs(ccp(S, L, L', T, T', Cd, CPSt)) = T .
  eq rhs(cp(L, L', T, T', CPSt)) = T' .
  eq rhs(ccp(L, L', T, T', Cd, CPSt)) = T' .
  eq rhs(cp(S, L, L', T, T', CPSt)) = T' .
  eq rhs(ccp(S, L, L', T, T', Cd, CPSt)) = T' .

  op cond : CritPair -> Condition .
  eq cond(cp(L, L', T, T', CPSt)) = nil .
  eq cond(ccp(L, L', T, T', Cd, CPSt)) = Cd .
  eq cond(cp(S, L, L', T, T', CPSt)) = nil .
  eq cond(ccp(S, L, L', T, T', Cd, CPSt)) = Cd .

  op setCond : CritPair Condition -> CritPair .
  eq setCond(ccp(S,L,L',T,T',Cd,CPSt),Cd') = ccp(S,L,L',T,T',Cd',CPSt) .
  eq setCond(ccp(  L,L',T,T',Cd,CPSt),Cd') = ccp(  L,L',T,T',Cd',CPSt) .
  eq setCond( cp(S,L,L',T,T',   CPSt),Cd') = ccp(S,L,L',T,T',Cd',CPSt) .
  eq setCond( cp(  L,L',T,T',   CPSt),Cd') = ccp(  L,L',T,T',Cd',CPSt) .

  op split : CritPair Term Term -> CritPair .
  eq split(ccp(S,L,L',T,T',Cd,CPSt),U,V) = ccp(S,L,L',T,T',Cd /\ U = V,CPSt) .
  eq split(ccp(  L,L',T,T',Cd,CPSt),U,V) = ccp(  L,L',T,T',Cd /\ U = V,CPSt) .
  eq split( cp(S,L,L',T,T',   CPSt),U,V) = ccp(S,L,L',T,T',      U = V,CPSt) .
  eq split( cp(  L,L',T,T',   CPSt),U,V) = ccp(  L,L',T,T',      U = V,CPSt) .
endfm

view CritPair from TRIV to CC-CRITICAL-PAIR is
  sort Elt to CritPair .
endv

fmod CRITICAL-PAIR-SET is
  pr CONFLUENCE-AUX .
  pr (SET * (op empty to none, op _,_ to __ [format (d n d)])){CritPair}
          * (sort Set{CritPair} to CritPairSet) .

  vars T T' T'' T''' T1 T1' T1'' T1''' T2 T2' T2'' T2''' : Term .
  vars L L' L1 L1' L2 L2' QI : Qid .
  var  CP CP' : CritPair .
  vars CPS CPS' : CritPairSet .
  var  M : Module .
  vars Cd Cd1 Cd2 : Condition .
  var  S : Sort .
  var  Subst : Substitution .
  var  QIL : QidList .
  vars Status Status' : CPStatus .
  var  All : Bool .
  vars Id Id' : String .

  op mark : String CritPairSet CPStatus -> CritPairSet .
  eq mark(Id, cp(Id, L, L', T, T', pending) CPS, Status) = cp(Id, L, L', T, T', Status) CPS  .
  eq mark(Id, ccp(Id, L, L', T, T', Cd, pending) CPS, Status) = ccp(Id, L, L', T, T', Cd, Status) CPS .
  eq mark(Id, CPS, Status) = CPS [owise] .

  op pendingCPs : CritPairSet -> CritPairSet .
  eq pendingCPs(cp(Id, L, L', T, T', pending) CPS) = cp(Id, L, L', T, T', pending) pendingCPs(CPS) .
  eq pendingCPs(ccp(Id, L, L', T, T', Cd, pending) CPS) = ccp(Id, L, L', T, T', Cd, pending) pendingCPs(CPS) .
  eq pendingCPs(CPS) = none [owise] .

  op getStatus : CritPair -> CPStatus .
  eq getStatus(cp(Id, L, L', T, T', Status)) = Status .
  eq getStatus(ccp(Id, L, L', T, T', Cd, Status)) = Status .

  op getId : CritPair -> String .
  eq getId(cp(Id, L, L', T, T', Status)) = Id .
  eq getId(ccp(Id, L, L', T, T', Cd, Status)) = Id .

  op setStatus : CritPair CPStatus -> CritPair .
  eq setStatus(cp(Id, L, L', T, T', Status), Status') = cp(Id, L, L', T, T', Status') .
  eq setStatus(ccp(Id, L, L', T, T', Cd, Status), Status') = ccp(Id, L, L', T, T', Cd, Status') .

  op delete : CritPairSet -> CritPairSet .
  op delete : CritPairSet CritPairSet -> CritPairSet .

  eq delete(CPS) = delete(CPS,none) .
  eq delete(cp(Id, L, L', T, T', Status) CPS,CPS') = delete(CPS,CPS' cp(Id, L, L', T, T',if Status == pending and-then T == T' then joined else Status fi)) .
  eq delete(ccp(Id, L, L', T, T', Cd, Status) CPS,CPS') = delete(CPS,CPS' ccp(Id, L, L', T, T', Cd,if Status == pending and-then T == T' then joined else Status fi)) .
  eq delete(none,CPS') = CPS' .

  op delete! : CritPairSet -> CritPairSet .
  op delete! : CritPairSet CritPairSet -> CritPairSet .
  eq delete!(CPS) = delete!(CPS,none) .
  eq delete!(CP CPS,CPS') = delete!(CPS,CPS' if lhs(CP) == rhs(CP) then none else CP fi) .
  eq delete!(none,  CPS') = CPS' .

  op simplify1 : CritPair Module ~> CritPair .
  eq simplify1(cp(Id, L, L', T, T',pending),M) = cp(Id, L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')), pending) .
  eq simplify1(ccp(Id, L, L', T, T', Cd, pending),M) = ccp(Id, L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')), Cd, pending) .

  op simplify : CritPairSet Module -> CritPairSet .
  op simplify : CritPairSet CritPairSet Module -> CritPairSet .
  eq simplify(CPS,M) = simplify(CPS,none,M) .

  eq simplify(CP CPS, CPS', M) = simplify(CPS,CPS' if getStatus(CP) == pending then simplify1(CP,M) else CP fi,M) .
  eq simplify(none,CPS',M) = CPS' .

  op maximalCPSet : CritPairSet Module ~> CritPairSet .
  op maximalCPSetAux : CritPair CritPairSet CritPairSet Module ~> CritPairSet .
  op moreGeneralCP : CritPair CritPair Module -> Bool .
 ceq maximalCPSet(CP CPS, M) = maximalCPSetAux(CP, CPS, none, M) if getStatus(CP) == pending .
  eq maximalCPSet(CPS,    M) = CPS [owise] .

  eq maximalCPSetAux(CP, CP' CPS, CPS', M)
    = if getStatus(CP') == pending
      then if moreGeneralCP(CP, CP', M)
           then maximalCPSetAux(CP, CPS, setStatus(CP', non-maximal) CPS', M)
           else if moreGeneralCP(CP', CP, M)
                then maximalCPSetAux(CP', CPS, setStatus(CP, non-maximal) CPS', M)
                else maximalCPSetAux(CP, CPS, CP' CPS', M)
                fi
           fi
      else maximalCPSetAux(CP, CPS, CP' CPS', M)
      fi .
  ceq maximalCPSetAux(CP, none, CP' CPS, M)
    = CP maximalCPSetAux(CP', CPS, none, M)
    if getStatus(CP') = pending .
  eq maximalCPSetAux(CP, none, CPS, M) = CP CPS [owise] .

  eq moreGeneralCP(cp(Id, L1, L1', T1, T1', Status), cp(Id', L2, L2', T2, T2', Status'), M)
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      (metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none].)))
       or-else
       metaMatch(M, ((eq T1 = T2' [none] .) (eq T1' = T2 [none] .)))) .
  eq moreGeneralCP(cp(Id, L1, L1', T1, T1', Status), ccp(Id', L2, L2', T2, T2', Cd2, Status'), M)
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      (metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none] .)))
       or-else
       metaMatch(M, ((eq T1 = T2' [none] .) (eq T1' = T2 [none] .)))) .
  eq moreGeneralCP(ccp(Id, L1, L1', T1, T1', Cd1, Status), cp(Id', L2, L2', T2, T2', Status'), M)
    = false .
  eq moreGeneralCP(ccp(Id, L1, L1', T1, T1', Cd1, Status),
                   ccp(Id', L2, L2', T2, T2', Cd2, Status'), M)
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      (metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none].) mgcpme(M, Cd1, Cd2)))
       or-else
       metaMatch(M, ((eq T1 = T2' [none].) (eq T1' = T2 [none].) mgcpme(M, Cd1, Cd2)))) .

  op mgcpme : Module Condition Condition -> EquationSet .
  eq mgcpme(M, T1 = T1' /\ Cd1, T2 = T2' /\ Cd2)
    = if sameKind(M, leastSort(M, T1), leastSort(M, T2))
      then ((eq T1 = T2 [none] .) (eq T1' = T2' [none] .) mgcpme(M, Cd1, Cd2))
      else (eq 'true.Bool = 'false.Bool [none] .)
      fi .
  eq mgcpme(M, T1 := T1' /\ Cd1, T2 := T2' /\ Cd2)
    = if sameKind(M, leastSort(M, T1), leastSort(M, T2))
      then ((eq T1 = T2 [none] .) (eq T1' = T2' [none] .) mgcpme(M, Cd1, Cd2))
      else (eq 'true.Bool = 'false.Bool [none] .)
      fi .
  eq mgcpme(M, T1 : S /\ Cd1, T2 : S /\ Cd2)
    = if sameKind(M, leastSort(M, T1), leastSort(M, T2))
      then ((eq T1 = T2 [none] .) mgcpme(M, Cd1, Cd2))
      else (eq 'true.Bool = 'false.Bool [none] .)
      fi .
  eq mgcpme(M, nil, nil) = none .
  eq mgcpme(M, Cd1, Cd2) = (eq 'true.Bool = 'false.Bool [none] .) [owise] . ----- This is too restrictive.
endfm

view CritPairSet from TRIV to CRITICAL-PAIR-SET is
  sort Elt to CritPairSet .
endv

--------------------------------------------------------------------------------
---- Context-Joinability and Unfeasible Conditional Critical Pairs
--------------------------------------------------------------------------------
----
---- Suppose that you get a nontrivial \emph{conditional critical pair} of the form:
---- $$ (u_1=v_1\wedge\ldots\wedge u_k=v_k\wedge v_{k+1}:=u_{k+1}\wedge\ldots\wedge v_{k+r}:=u_{k+r}) \Rightarrow t=t'$$
----
---- \noindent (of course the \emph{order} of ordinary and matching equations can be \emph{mixed}.)
----
---- Perform the following transformation:
----
---- \renewcommand{\labelenumi}{(\alph{enumi})}
---- \begin{enumerate}
---- \item Any $v_{i}:=u_{i}$ becomes a condition $u_i\rightarrow v_i$.
---- \item Any $u_{i}=v_{i}$ where, say, $v_i$ is a \emph{ground term in canonical form} becomes $u_i\rightarrow v_i$.
---- \item For all other $u_{i}:=v_{i}$ introduce a \emph{fresh new variable} $x_i$ of the smallest of the sorts of $u_i$ and $v_i$
---- so that the rules are \emph{sort decreasing},\footnote{If the sorts are not comparable, then pick one of those sorts
---- non-deterministically. Or if $lub(ls(u_i),ls(v_i)$ is singleton, then pick $lnb$.} and \emph{two conditions} $u_i\rightarrow x_i$
---- and $v_i\rightarrow x_i$.
---- \end{enumerate}
----
---- Call $C$ the new condition so obtained, and $X$ the \emph{variables} in $C$ and $t$ and $t'$. Get the new $CCP$.
----
---- To check whether the CCP is \emph{context joinable}:
----
---- \renewcommand{\labelenumi}{(\roman{enumi})}
---- \begin{enumerate}
---- \item Add the new variables $x$ as constants $\overline{X}$.
---- \item Add to the rules $R$ the new \emph{ground} rewrite rules $\overline{C}$ plus an equality operator $eq$ with rules
---- $eq(x,x)\rightarrow tt$. Call this theory $\hat{\cR}_{\overline{C}}$.
---- \item In $\hat{\cR}_{\overline{C}}$, search $eq(\overline{t},\overline{t'})\Rightarrow ^{+} tt$ up to some predetermined
---- depth (using the \verb#search# command).
---- \end{enumerate}
----
---- If the search is successful, then the CCP is context joinable.

fmod CRC-CONTEXT-JOINABILITY-UNFEASIBILITY is
  pr CRITICAL-PAIR-SET .
  pr TERMSET-FM .
  pr UNIFIERS .

  sort Tuple{RuleSet, OpDeclSet}  . op ((_,_)) : RuleSet  OpDeclSet -> Tuple{RuleSet,  OpDeclSet} [ctor] .
  op getRls : Tuple{RuleSet, OpDeclSet} -> RuleSet .
  op getOps : Tuple{RuleSet, OpDeclSet} -> OpDeclSet .
  eq getRls((RlS,ODS)) = RlS .
  eq getOps((RlS,ODS)) = ODS .

  sort Tuple{TermList, OpDeclSet} . op ((_,_)) : TermList OpDeclSet -> Tuple{TermList, OpDeclSet} [ctor] .
  op getTerms : Tuple{TermList, OpDeclSet} -> TermList .
  op getOps   : Tuple{TermList, OpDeclSet} -> OpDeclSet .
  eq getTerms((TL,ODS)) = TL  .
  eq getOps  ((TL,ODS)) = ODS .

  sort Tuple{QidSet, Condition}   . op ((_,_)) : QidSet   Condition -> Tuple{QidSet,   Condition} [ctor] .
  op getVars      : Tuple{QidSet, Condition} -> QidSet .
  op getCondition : Tuple{QidSet, Condition} -> Condition .
  eq getVars     ((VS,Cd)) = VS .
  eq getCondition((VS,Cd)) = Cd .

  op joinability-depth : -> Nat .
  eq joinability-depth = 10 .

  vars QI QI' F : Qid .
  var  VS : QidSet .
  var  V : Variable .
  var  Ct : Constant .
  vars T T' T'' T''' : Term .
  vars TL TL' : TermList .
  var  TS : TermSet .
  vars Cd Cd' : Condition .
  var  N : Nat .
  vars M M' M'' : Module .
  var  Tp : Type .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  CP : CritPair .
  var  CPS : CritPairSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  RlS : RuleSet .
  var  S : Sort .
  var  K : Kind .
  var  KS : KindSet .
  var  Status CPSt : CPStatus .
  vars Id Id' : String .

  op crcContextJoinableAndUnfeasibleCPs : Module CritPairSet -> CritPairSet .
  op $crcContextJoinableAndUnfeasibleCPs : Module CritPair -> CritPair .
  op crcContextJoinable : Module Term Term -> Bool .
  op unfeasible : Module Module Module Condition -> Bool .

  eq crcContextJoinableAndUnfeasibleCPs(M, ccp(Id, QI, QI', T, T', Cd, pending) CPS)
    = if preunfeasible(M, Cd)
      then ccp(Id, QI, QI', T, T', Cd, unfeasible)
      else $crcContextJoinableAndUnfeasibleCPs(M, ccp(Id, QI, QI', T, T', Cd, pending))
      fi
      crcContextJoinableAndUnfeasibleCPs(M, CPS) .
  eq crcContextJoinableAndUnfeasibleCPs(M, CPS) = CPS [owise] .

 ceq $crcContextJoinableAndUnfeasibleCPs(M, ccp(Id, QI, QI', T, T', Cd, pending))
    = if crcContextJoinable(M'', getTerms(vars2cts(T)), getTerms(vars2cts(T')))
      then ccp(Id, QI, QI', T, T', Cd, context-joinable)
      else if unfeasible(M, M', M'', Cd')
           then ccp(Id, QI, QI', T, T', Cd, unfeasible)
           else ccp(Id, QI, QI', T, T', Cd, pending)
           fi
      fi
    if Cd' := transform(M, Cd)            ---- new CCP
    /\ M' := rulify(M)                    ---- turns equations into rules, and equational conditions into rewrites
    /\ M'' := addRls(                     ---- $\hat{\cR}_{\overline{C}}$
               (getRls(groundRls(Cd'))
                equalRls(getKinds(M))),
               addOps(
                 (op 'tt : nil -> '`[Thruth`] [none] .
                  equalOps(getKinds(M))
                  getOps(groundRls(Cd'))
                  getOps(vars2cts(T))
                  getOps(vars2cts(T'))),
                 addSorts('Thruth, M'))) .

  eq crcContextJoinable(M, T, T')
    = metaSearch(M, 'equal[T, T'], 'tt.`[Thruth`], nil, '+, joinability-depth, 0) =/= failure .

  op preunfeasible : Module Condition -> Bool .
  eq preunfeasible(M, T = T' /\ Cd)
    = if ---- ground irreducible distinct terms
         vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T))
         and-then
         vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T'))
         and-then T =/= T'
      then true
      else preunfeasible(M, Cd)
      fi .
  eq preunfeasible(M, T => T' /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, T : S /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, T := T' /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, nil) = false .

  eq unfeasible(M, M', M'', T => T' /\ Cd)
    = ---- if T' :: Variable
      ---- then unfeasible(M, M', M'', Cd)
      ---- else
           if | searchNormalForms(M'', getTerms(vars2cts(T)), leastSort(M, T), 0) | <= 1
           then unfeasible(M, M', M'', Cd)
           else checkUnfeasibility(M', restoreVars(searchNormalForms(M'', getTerms(vars2cts(T)), leastSort(M, T), 0)))
                or-else
                unfeasible(M, M', M'', Cd)
           fi
      ---- fi
      .
  eq unfeasible(M, M', M'', nil) = false .

  op restoreVars : TermSet -> TermSet . ---- new vars start with ##
  op restoreVarsAux : TermList -> TermList .
  eq restoreVars(T | TS) = restoreVarsAux(T) | restoreVars(TS) .
  eq restoreVars(emptyTermSet) = emptyTermSet .
  eq restoreVarsAux((V, TL)) = (V, restoreVarsAux(TL)) .
  eq restoreVarsAux((Ct, TL))
    = if substr(string(Ct), 0, 2) == "##"
      then qid(substr(string(getName(Ct)), 2, _-_(length(string(getName(Ct))), 2)) + ":" + string(getType(Ct)))
      else Ct
      fi,
      restoreVarsAux(TL) .
  eq restoreVarsAux((F[TL], TL')) = (F[restoreVarsAux(TL)], restoreVarsAux(TL')) .
  eq restoreVarsAux(empty) = empty .

  op searchNormalForms : Module Term Type Nat -> TermSet .
  eq searchNormalForms(M, T, Tp, N)
    = if metaSearch(M, T, qid("X:" + string(Tp)), nil, '!, joinability-depth, N) =/= failure
      then getTerm(metaSearch(M, T, qid("X:" + string(Tp)), nil, '!, joinability-depth, N))
           | searchNormalForms(M, T, Tp, s N)
      else emptyTermSet
      fi .

  op checkUnfeasibility : Module TermSet -> Bool .
  op checkUnfeasibility : Module Term TermSet -> Bool .

  eq checkUnfeasibility(M, T | TS) = checkUnfeasibility(M, T, TS) or-else checkUnfeasibility(M, TS) .
  eq checkUnfeasibility(M, emptyTermSet) = false .

  eq checkUnfeasibility(M, T, T' | TS)
    = if unifiers(M, T =? T') == empty ---- no unifiers in common... only C, LU, RU, CU, and ACU
         and-then (strongly-irreducible(M, T) and-then strongly-irreducible(M, T'))
      then true
      else checkUnfeasibility(M, T, TS)
      fi .
  eq  checkUnfeasibility(M, T, emptyTermSet) = false .

  op strongly-irreducible : Module Term -> Bool .
  eq strongly-irreducible(M, T)
    = metaNarrowingSearch(M, T, qid("X:" + string(leastSort(M, T))), '+, unbounded, 'none, 0) == failure .

  op groundRls : Condition -> Tuple{RuleSet, OpDeclSet} .
  op groundRls : Condition RuleSet OpDeclSet -> Tuple{RuleSet, OpDeclSet} .
  eq groundRls(Cd) = groundRls(Cd, none, none) .
  eq groundRls(T => T' /\ Cd, RlS, ODS)
    = groundRls(Cd, rl getTerms(vars2cts(T)) => getTerms(vars2cts(T')) [none] . RlS, getOps(vars2cts(T)) getOps(vars2cts(T')) ODS) .
  eq groundRls(Cd, RlS, ODS) = (RlS, ODS) [owise] .

  op transform : Module Condition -> Condition .
  op transform : Module Condition Nat -> Condition .

  eq transform(M, Cd) = transform(M, Cd, 0) .
  eq transform(M, T = T' /\ Cd, N)
    = if ---- T is irreducible but T' isn't
         vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T))
         and-then
         not (vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T')))
      then T' => T /\ transform(M, Cd, N)
      else if ---- T' is irreducible but T isn't
              not (vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T)))
              and-then
              vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T'))
           then T => T' /\ transform(M, Cd, N)
           else ---- either none or both of them are irreducible
                if | glbSorts(M, leastSort(M, T), leastSort(M, T')) | == 1
                then T => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T'))))
                     /\ T' => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T'))))
                     /\ transform(M, Cd, s N)
                else T => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T))) ---- should we use the kind instead of one of them?
                     /\ T' => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T)))
                     /\ transform(M, Cd, s N)
                fi
           fi
      fi .
  eq transform(M, T := T' /\ Cd, N) = T' => T /\ transform(M, Cd, N) .
  eq transform(M, T => T' /\ Cd, N) = T => T' /\ transform(M, Cd, N) .
  eq transform(M, T : S /\ Cd, N) = T : S /\ transform(M, Cd, N) .
  eq transform(M, nil, N) = nil .

  op equalOps : KindSet -> OpDeclSet . ---- from MTT-transformations.1.5f.maude
  eq equalOps(K ; KS) = (op 'equal : K K -> 'Thruth [none] .) equalOps(KS) .
  eq equalOps(none) = none .

  op equalRls : KindSet -> RuleSet . ---- from MTT-transformations.1.5f.maude
  eq equalRls(K ; KS)
    = (rl 'equal[qid("X:" + string(K)), qid("X:" + string(K))] => qid("tt.`[Thruth`]") [none] .)
      equalRls(KS) .
  eq equalRls(none) = none .

  op vars2cts : Term -> Tuple{TermList, OpDeclSet} .
  op vars2cts : Term OpDeclSet -> Tuple{TermList, OpDeclSet} .
  op vars2cts : TermList OpDeclSet -> Tuple{TermList, OpDeclSet} .
  eq vars2cts(TL) = vars2cts(TL, none) .
  eq vars2cts(V, ODS)
    = (qid("##" + string(getName(V)) + "." + string(getType(V))),
       op qid("##" + string(getName(V))) : nil -> getType(V) [none] . ODS) .
  eq vars2cts(Ct, ODS) = (Ct, ODS) .
  eq vars2cts(F[TL], ODS) = (F[getTerms(vars2cts(TL))], getOps(vars2cts(TL)) ODS) .

 ceq vars2cts((T, TL), ODS)
    = ((getTerms(vars2cts(T)), getTerms(vars2cts(TL))), (getOps(vars2cts(T)) getOps(vars2cts(TL)) ODS))
    if TL =/= empty .

  op rulify : Module -> Module .
  op rulify : Module EquationSet -> RuleSet .
  op rulify : Module MembAxSet -> MembAxSet .
  op rulify : Module RuleSet -> RuleSet .
  ---- takes a module an makes all its equations into rules

  eq rulify(M) = addRls(rulify(M, getEqs(M)), setRls(setEqs(setMbs(M, rulify(M, getMbs(M))), none), rulify(M, getRls(M)))) .

  eq rulify(M, eq T = T' [AtS] . EqS) = (rl T => T' [AtS] .) rulify(M, EqS) .
  eq rulify(M, ceq T = T' if Cd [AtS] . EqS) = (crl T => T' if transform(M, Cd) [AtS] .) rulify(M, EqS) .
  eq rulify(M, (none).EquationSet) = none .

  eq rulify(M, rl T => T' [AtS] . RlS) = (rl T => T' [AtS] .) rulify(M, RlS) .
  eq rulify(M, crl T => T' if Cd [AtS] . RlS) = (crl T => T' if transform(M, Cd) [AtS] .) rulify(M, RlS) .
  eq rulify(M, (none).RuleSet) = none .

  eq rulify(M, mb T : S [AtS] . MAS) = (mb T : S [AtS] .) rulify(M, MAS) .
  eq rulify(M, cmb T : S if Cd [AtS] . MAS) = (cmb T : S if transform(M, Cd) [AtS] .) rulify(M, MAS) .
  eq rulify(M, (none).MembAxSet) = none .
endfm

fmod CONFLUENCE-CHECK is
  pr CRITICAL-PAIR-SET .
  pr CONFLUENCE-AUX .
  pr NARROWING .
  pr CRC-CONTEXT-JOINABILITY-UNFEASIBILITY .
  pr EQ-FAMILY .

  sort Tuple{CritPairSet, CritPairSet}  . op ((_,_)) : CritPairSet  CritPairSet -> Tuple{CritPairSet,  CritPairSet} [ctor] .
  op p1 : Tuple{CritPairSet, CritPairSet} -> CritPairSet .
  op p2 : Tuple{CritPairSet, CritPairSet} -> CritPairSet .
  eq p1((CPS,CPS')) = CPS  .
  eq p2((CPS,CPS')) = CPS' .

  sort Tuple{CritPairSet, Nat} . op ((_,_)) : CritPairSet Nat -> Tuple{CritPairSet, Nat} [ctor] .
  op getCPs   : Tuple{CritPairSet, Nat} -> CritPairSet .
  op getIndex : Tuple{CritPairSet, Nat} -> Nat .
  eq getCPs  ((CPS,N)) = CPS .
  eq getIndex((CPS,N)) = N   .
  op addCPs : CritPairSet Tuple{CritPairSet,Nat} -> Tuple{CritPairSet,Nat} .
  eq addCPs(CPS,(CPS',N)) = (CPS CPS',N) .

  sort Tuple{Module, QidSet}   . op ((_,_)) : Module   QidSet -> Tuple{Module,   QidSet} [ctor] .
  op getModule : Tuple{Module, QidSet} -> Module .
  op getCts    : Tuple{Module, QidSet} -> QidSet .
  eq getModule((M,VS)) = M  .
  eq getCts   ((M,VS)) = VS .

  vars M M' : Module .
  vars T T' T'' T''' T'''' T1 T1' T2 T2' T1'' T2'' LHS RHS : Term .
  vars CP CP' : CritPair .
  vars CPS CPS' CPS'' : CritPairSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' EqS'' : EquationSet .
  var  Subst : Substitution .
  var  SubstS : SubstitutionSet .
  vars AtS AtS' : AttrSet .
  vars N N' N'' N''' : Nat .
  vars X F S L L' L1 L1' L2 L2' : Qid .
  vars TL TL' : TermList .
  vars Cd Cd1 Cd2 Cond : Condition .
  vars Sb Sb' : Substitution .
  var  Ct : Constant .
  var  V : Variable .
  vars Cx Cx' : Context .
  var  RTS : ResultTripleSet .
  var  TpL : TypeList .
  var  Tp : Type .
  var  NeNL : NeNatList .
  var  ODS : OpDeclSet .
  var  VS : QidSet .
  var  Status : CPStatus .
  vars Id Id' St1 St2 : String .
  var  QIL : QidList .
  var  Atts : AttrSet .
  var EFM : EqFamilyMap .

**** We declare sorts for critical pairs (\texttt{CritPair}) and for sets of
**** critical pairs (\texttt{CritPairSet}), and constructors for them.  The
**** constructors for critical pairs (\texttt{cp}) and for conditional critical
**** pairs (\texttt{ccp}) have, respectively, two and four arguments. The two
**** arguments of \texttt{cp} and the first two of \texttt{ccp} are the terms
**** forming the critical pair. The two last arguments in a conditional critical
**** pair correspond to the condition, which is given following the conventions
**** for conditions in membership axioms, equations, and rules in the
**** \texttt{META-LEVEL} module.

**** Given a specification $\mathcal{S}$, the \texttt{critPairs} function finds
**** all the critical pairs between the equations in $\mathcal{S}$ considered
**** as rules, oriented from left to right.

**** One critical pair is generated for each unifier for each of the possible
**** nonvariable overlappings of the lefthand sides of any two equations in the
**** module. These critical pairs are calculated by finding all the possible
**** such pairs for each of the equations in the module (\texttt{critPairs1})
**** with a renamed copy of each one of the other equations in the module
**** (including itself \texttt{critPairs2}). For each pair of equations, their
**** left sides are unified at any nonvariable position of the term of the
**** (first equation \texttt{critPairs3}), and then a critical pair is
**** constructed for each one of the solutions of the unification problem
**** (\texttt{critPairs4}).

**** As said above, the critical pair is formed by \texttt{critPairs4} for a
**** pair of equations with an overlapping at some position with some
**** substitution. In the cases when one or both of the equations involved are
**** conditional, then the conjunction of the conditions with the substitution
**** applied to them is placed as the condition of the critical pair.

---- nov 7th, 2008
---- The computation of conditional critical pairs is accomplished using Santiago
---- Escobar's narrowing functionality.
---- Given equations
----   l(X) = r(X, Y) if C(X, Y)
----   l'(X') = r'(X', Y') if C'(X', Y')
---- we narrow the term
----   # l(X) # r(X, Y) # C(X, Y) #
---- (with 2nd and 3rd args. frozen, all other frozen attributes are removed)
---- using the rule
----   l'(X') => # r'(X', Y') # C'(X', Y') #
---- critPairs(M, Eq, Eq) prepares a module with the equation Eq modified as above
---- and uses metaNarrowSearchGenAll to take a narrowing step on a term as the
---- one above obtained from Eq'.
---- metaNarrowSearchGenAll returns a set of solutions of sort ResultContextSet.
---- A result context is a 10-tuple with information on the narrowing; from
---- these results we take the resulting term with the substitution applied,
---- from which we build the critical pair.

  op crcCritPairs : Module -> CritPairSet .
  op crcCritPairs : Module EquationSet EquationSet Nat -> Tuple{CritPairSet, Nat} .

  eq crcCritPairs(M) = getCPs(crcCritPairs(M, getEqs(M), getEqs(M), 0)) .

----    ---- Avenhaus & Loria-Saenz discard nonproper critical pairs, i.e., the critical pair of
----    ---- an equation with itself at the top. Notice that there is always (at least) such an
----    ---- overlapping. They can discard these matches directly because they only consider the
----    ---- free case. In our case, there might be other matches of one rule with itself at the top.
----    ---- What we do is that, if there is a single overlap between an equation with itself, we do
----    ---- not generate the corresponding critical pair. Notice that if there is more than one
----    ---- we could look the trivial one and discard it, but we don't do this in that case.
  ceq crcCritPairs(M, Eq EqS, Eq' EqS', N)
    = (CPS CPS' CPS'', N''')
    if (CPS, N') := crcCritPairs1(M,Eq,Eq',N)
    /\ (CPS', N'') := crcCritPairs(M, Eq, EqS', N')
    /\ (CPS'', N''') := crcCritPairs(M, EqS, Eq' EqS', N'') .
  eq crcCritPairs(M, none, EqS, N) = (none, N) .
  eq crcCritPairs(M, EqS, none, N) = (none, N) .

  op sym-crcCritPairs@ : Module Nat -> Tuple{CritPairSet,Nat} .
  eq sym-crcCritPairs@(M,N) = sym-crcCritPairs1(M,pickEq(N,getEqs(M)),dropEqs(N,getEqs(M)),(none,0)) .

  op sym-crcCritPairs : Module EquationSet -> Tuple{CritPairSet, Nat} .
  eq sym-crcCritPairs(M,EqS) = sym-crcCritPairs(M,EqS,EqS,(none,0)) .

  op sym-crcCritPairs : Module EquationSet EquationSet Tuple{CritPairSet, Nat} -> Tuple{CritPairSet, Nat} .
  eq sym-crcCritPairs(M, Eq EqS, Eq EqS', (CPS,N)) =
       sym-crcCritPairs(M,EqS,EqS',sym-crcCritPairs1(M,Eq,Eq EqS',(CPS,N))) .
  eq sym-crcCritPairs(M, none, none, (CPS,N)) = (CPS,N) .

  op sym-crcCritPairs1 : Module Equation EquationSet Tuple{CritPairSet, Nat} -> Tuple{CritPairSet, Nat} .
  eq sym-crcCritPairs1(M,Eq,Eq' EqS', (CPS,N)) =
    sym-crcCritPairs1(M,Eq,EqS',addCPs(CPS,crcCritPairs1(M,Eq,Eq',N))) .
  eq sym-crcCritPairs1(M,Eq,none,(CPS,N)) = (CPS,N) .

  op crcCritPairs1 : Module Equation Equation Nat -> Tuple{CritPairSet, Nat} .
  eq crcCritPairs1(M,Eq,Eq',N) =
     prepNarrowingSols(M, getLabel(Eq), getLabel(Eq'),
                       getCts(makeNarrowingModule(M, Eq, Eq')),
                       toResultTripleSet(metaNarrowSearch(
                         getModule(makeNarrowingModule(M, Eq, Eq')),
                         ---- makeNarrowingModule removes frozen attributes from M, removes eqs
                         ---- and rls from M, and leaves a prepared version of Eq as single rule
                         '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
                         qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))),
                         '+, unbounded, 'none)), N) .

  op makeNarrowingModule : Module Equation Equation -> Tuple{Module, QidSet} .
  ---- Returns the modified module and the set of variables in the rhs and condition of the
  ---- 1st eq not in its lhs (it actually returns the set of constants, not variables).
  ---- Constant names are generated just be adding a # in front of the variable's name.
 ceq makeNarrowingModule(M, Eq, Eq')
    = (setRls(
         setEqs(
           addOps(
             (op '#_#_# : leastSort(M, lhs(Eq)) '#ConditionList -> leastSort(M, lhs(Eq)) [none] .
              op '#_#_#_# : leastSort(M, lhs(Eq')) leastSort(M, rhs(Eq')) '#ConditionList -> leastSort(M, lhs(Eq')) [frozen(2 3)] .
              op 'nil : nil -> '#ConditionList [none] .
              op '_/\_ : '#Condition '#ConditionList -> '#ConditionList [none] .
              opCondition(M, cond(Eq) /\ cond(Eq'))
              opNewCts(VS)),
             addSorts('#Condition ; '#ConditionList, removeFrozen(M))),
           none),
         rl T' => '#_#_#[vars2narrowCts(T'', VS), vars2narrowCts(T, VS)] [narrowing] .),
       vars2narrowCts(VS))
     if T := makeNarrowingCond(cond(Eq))
     /\ T' := getTerm(metaNormalize(M, lhs(Eq)))
     /\ T'' := getTerm(metaNormalize(M, rhs(Eq)))
     /\ VS := (vars(T'') ; vars(T)) \ vars(T') . ---- vars to be made constants

  op vars2narrowCts : Term QidSet -> Term .
  eq vars2narrowCts(V, VS)
    = if V in VS
      then qid("#" + string(getName(V)) + "#." + string(getType(V)))
      else V
      fi .
  eq vars2narrowCts(Ct, VS) = Ct .
  eq vars2narrowCts(F[TL], VS) = F[vars2narrowCts(TL, VS)] .
  eq vars2narrowCts((T, TL), VS) = (vars2narrowCts(T, VS), vars2narrowCts(TL, VS)) .
  eq vars2narrowCts(empty, VS) = empty .

  op vars2narrowCts : QidSet -> QidSet .
  eq vars2narrowCts(V ; VS) = qid("#" + string(getName(V)) + "#." + string(getType(V))) ; vars2narrowCts(VS) .
  eq vars2narrowCts(none) = none .

  op opNewCts : QidSet -> OpDeclSet .
  eq opNewCts(V ; VS) = (op qid("#" + string(getName(V)) + "#") : nil -> getType(V) [none] .) opNewCts(VS) .
  eq opNewCts(none) = none .

  op opCondition : Module Condition -> OpDeclSet .
  eq opCondition(M, T => T' /\ Cond)
    = (op '_=>_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#Condition [none] .)
      opCondition(M, Cond) .
  eq opCondition(M, T = T' /\ Cond)
    = (op '_=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#Condition [none] .)
      opCondition(M, Cond) .
  eq opCondition(M, T := T' /\ Cond)
    = (op '_:=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#Condition [none] .)
      opCondition(M, Cond) .
  eq opCondition(M, T : S /\ Cond)
    = (op '_:_ : getKind(M, leastSort(M, T)) 'Sort -> '#Condition [none] .)
      opCondition(M, Cond) .
  eq opCondition(M, nil) = none .

  op prepNarrowingSols : Module Qid Qid QidSet ResultTripleSet Nat -> Tuple{CritPairSet, Nat} .
  eq prepNarrowingSols(M, L, L', VS, {'#_#_#_#[T, T', T''], Tp, Sb} | RTS, N)
    = (ccp(name(getName(M), N), L, L', getCPTerm(substitute(M, T, Sb), VS), getCPTerm(T', VS),
           makeCond(T'') /\ makeCond(getCPCond(substitute(M, T, Sb), VS)), pending)
       getCPs(prepNarrowingSols(M, L, L', VS, RTS, s N)),
       getIndex(prepNarrowingSols(M, L, L', VS, RTS, s N))) .
  eq prepNarrowingSols(M, L, L', VS, empty, N) = (none, N) .

  eq ccp(Id, L, L', T, T', nil, Status) = cp(Id, L, L', T, T', Status) .

  op getCPTerm : Term QidSet -> Term .
  op $getCPTerm : Term -> Term .
  op $getCPTerm : TermList -> TermList .
  op getCPCond : Term QidSet -> Term .
  op getCPCond : TermList QidSet -> TermList .
  op restoreVars : TermList QidSet -> TermList .

  eq getCPTerm(T, VS) = restoreVars($getCPTerm(T), VS) .

  eq $getCPTerm((Ct, TL)) = (Ct, $getCPTerm(TL)) .
  eq $getCPTerm((V, TL)) = (V, $getCPTerm(TL)) .
  eq $getCPTerm(('#_#_#[T, T'], TL)) = ($getCPTerm(T), $getCPTerm(TL)) .
  eq $getCPTerm((F[TL], TL')) = (F[$getCPTerm(TL)], $getCPTerm(TL')) [owise] .
  eq $getCPTerm(empty) = empty .

  eq getCPCond((Ct, TL), VS) = getCPCond(TL, VS) .
  eq getCPCond((V, TL), VS) = getCPCond(TL, VS) .
  eq getCPCond(('#_#_#[T, T'], TL), VS) = restoreVars(T', VS) .
  eq getCPCond((F[TL], TL'), VS)
    = if getCPCond(TL, VS) =/= 'nil.#ConditionList then getCPCond(TL, VS) else getCPCond(TL', VS) fi
    [owise] .
  eq getCPCond(empty, VS) = 'nil.#ConditionList .

  eq restoreVars((Ct, TL), VS)
    = (if Ct in VS then qid(string(getName(Ct)) + ":" + string(getType(Ct))) else Ct fi, restoreVars(TL, VS)) .
  eq restoreVars((V, TL), VS) = (V, restoreVars(TL, VS)) .
  eq restoreVars((F[TL], TL'), VS) = (F[restoreVars(TL, VS)], restoreVars(TL', VS)) .
  eq restoreVars(empty, VS) = empty .

  op makeNarrowingCond : Condition -> Term .
  op makeCond : Term -> Condition .
  op makeCondAux : TermList -> Condition .

  eq makeNarrowingCond(T => T' /\ Cond) = '_/\_['_=>_[T, T'], makeNarrowingCond(Cond)] .
  eq makeNarrowingCond(T : S /\ Cond) = '_/\_['_:_[T, S], makeNarrowingCond(Cond)] .
  eq makeNarrowingCond(T = T' /\ Cond) = '_/\_['_=_[T, T'], makeNarrowingCond(Cond)] .
  eq makeNarrowingCond(T := T' /\ Cond) = '_/\_['_:=_[T, T'], makeNarrowingCond(Cond)] .
  eq makeNarrowingCond(nil) = 'nil.#ConditionList .

  eq makeCond('_/\_[TL]) = makeCondAux(TL) .
  eq makeCond('_=>_[T, T']) = T => T' .
  eq makeCond('_:_[T, T']) = T : T' .
  eq makeCond('_=_[T, T']) = T = T' .
  eq makeCond('_:=_[T, T']) = T := T' .
  eq makeCond('nil.#ConditionList) = nil .

  eq makeCondAux(('_/\_[TL], TL')) = makeCondAux((TL, TL')) .
  eq makeCondAux(('_=>_[T, T'], TL)) = T => T' /\ makeCondAux(TL) .
  eq makeCondAux(('_:_[T, T'], TL)) = T : T' /\ makeCondAux(TL) .
  eq makeCondAux(('_=_[T, T'], TL)) = T = T' /\ makeCondAux(TL) .
  eq makeCondAux(('_:=_[T, T'], TL)) = T := T' /\ makeCondAux(TL) .
  eq makeCondAux(('nil.#ConditionList, TL)) = makeCondAux(TL) .
  eq makeCondAux(empty) = nil .

  op getLabel : Equation -> Qid .
  op getLabel : Rule -> Qid .
  eq getLabel(eq LHS = RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(ceq LHS = RHS if Cond [AtS] .) = getLabel(AtS) .
  eq getLabel(rl LHS => RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(crl LHS => RHS if Cond [AtS] .) = getLabel(AtS) .

  ---- removes frozen attributes
  op removeFrozen : Module -> Module .
  op removeFrozen : OpDeclSet -> OpDeclSet .
  eq removeFrozen(M) = setOps(M, removeFrozen(getOps(M))) .
  eq removeFrozen(op F : TpL -> Tp [frozen(NeNL) AtS] . ODS)
    = op F : TpL -> Tp [AtS] . removeFrozen(ODS) .
  eq removeFrozen(ODS) = ODS .

  op confluenceCheck : Module ~> CritPairSet .
  op cpsError : QidList -> [CritPairSet] .

  eq confluenceCheck(M)
    = crcContextJoinableAndUnfeasibleCPs(M,
        maximalCPSet(
          delete(
            simplify(
              delete(
                crcCritPairs(M)),
              M)),
          M)) .

  op sym-confluenceCheck : Module ~> CritPairSet .
  op sym-confluenceCheck : Module EqFamilyMap ~> CritPairSet .
  eq sym-confluenceCheck(M) = sym-confluenceCheck(M,getEqFamilies(M)) .
  eq sym-confluenceCheck(M,((F,TpL) |-> EqS) EFM)
    = crcContextJoinableAndUnfeasibleCPs(M,
        maximalCPSet(
          delete!(
            simplify(
              delete!(
                getCPs(sym-crcCritPairs(M,EqS))),
              M)),
	M)) sym-confluenceCheck(M,EFM) .
  eq sym-confluenceCheck(M,nil) = none .
endfm

view EqCondition from TRIV to META-LEVEL is sort Elt to EqCondition . endv

---
--- Simplified Critical Pair Generation Routines
--- Requirements:
--- [1] all A/C/U symbols must be constructors
--- [2] no matching/sort conditions anywhere
--- [3] all equations satisfy vars(RHS) <= vars(LHS)
--- [4] all direct subterms of each LHS of each equation are constructors
--- Implementation Notes:
--- [1] all important functions fully tail-recursive
--- [2] subsumption check optimized by only considering critical pairs generated from same family
---
fmod SIMPLE-CRITPAIR is
  pr MAYBE-QID           . --- MaybeQid sort
  pr STMT-EXTRA          . --- declaration projections
  pr RENAME-TERM-AUX     . --- term renaming
  pr UNIFIERS            . --- unification convenience routines
  pr EQ-FAMILY           . --- generate subsort-polymorphic equation families
  pr EQUATIONSET-FUNCTOR . --- functor for critical pair subsumption
  pr CRITICAL-PAIR-SET   . --- standard critical pair set definition
  pr CRC-CONTEXT-JOINABILITY-UNFEASIBILITY . --- preunfeasible
  pr MAP{Term,EqCondition} * (sort Map{Term,EqCondition} to TermConditionMap) .

  var M : Module .
  var N : Nat .
  var Q : Qid .
  var QL : QidList .
  var TL : TypeList .
  var E E' : Equation .
  var ES ES' : EquationSet .
  var EFM : EqFamilyMap .
  var EPS : EqPairSet .
  var ODS : OpDeclSet .
  var S S' : Substitution .
  var SS : SubstitutionSet .
  var SPS : SubstitutionPairSet .
  var T1 T2 T1' T2' : Term .
  var C C' A A' : EqCondition .
  var CP CP' : SimpleCritPair .
  var CPS CPS' : SimpleCritPairSet .
  var OCPS : CritPairSet .
  var D D1 D2 : NameData .
  var TCM : TermConditionMap .

  sort EquationPair EqPairSet .
  subsort EquationPair < EqPairSet .
  op ((_,_)) : Equation Equation -> EquationPair [ctor] .
  op _|_ : EqPairSet EqPairSet -> EqPairSet [ctor assoc comm id: .EqPairSet] .
  op .EqPairSet : -> EqPairSet [ctor] .
  -------------------------------------
  sort CommTermPair .
  op ctp : Term Term -> CommTermPair [ctor comm] .
  ------------------------------------------------
  sort SimpleCritPair SimpleCritPairSet .
  subsort SimpleCritPair < SimpleCritPairSet .
  op cp  : NeQidList CommTermPair EqCondition EqCondition -> SimpleCritPair [ctor] .
  op __  : SimpleCritPairSet SimpleCritPairSet -> SimpleCritPairSet [ctor assoc comm id: .SimpleCritPairSet format (d n d)] .
  op .SimpleCritPairSet : -> SimpleCritPairSet [ctor] .
  -----------------------------------------------------
  op getOpId : SimpleCritPair -> NeQidList .
  eq getOpId(cp(Q QL,ctp(T1,T2),C,A)) = Q QL .

  op getEqPairs  : EquationSet -> EqPairSet .
  op getEqPairs  : EquationSet EquationSet EqPairSet -> EqPairSet .
  op getEqPairs2 : Equation EquationSet EqPairSet -> EqPairSet .
  --------------------------------------------------------------
  eq getEqPairs(ES) = getEqPairs(ES,none,.EqPairSet) .

  eq getEqPairs(E ES,ES',EPS) = getEqPairs(ES,E ES',EPS | getEqPairs2(E,ES',.EqPairSet)) .
  eq getEqPairs(none,ES',EPS) = EPS .

  eq getEqPairs2(E,E' ES,EPS) = getEqPairs2(E,ES,EPS | (E,E')) .
  eq getEqPairs2(E,none, EPS) = EPS .

  --- NOTE: This function MUST be tail-recursive to handle large modules.
  --- NOTE: Checking critical pairs under a TermConditionMap is equivalent
  ---       to checking for critical pairs in a specific kind of membership
  ---       equational logic theory.
  ---       This functionality is useful in several ways:
  ---       [1] it may be easier to write your function without all these checks occuring explicitly
  ---       [2] generating critical pairs means that we can consider fewer critical pairs
  ---       [3] but this also means that our performance is better, since the unfeasibility check is cheap
  op getSimpleCritPairs : Module -> SimpleCritPairSet .
  op getSimpleCritPairs : Module TermConditionMap -> SimpleCritPairSet .
  op getSimpleCritPairs : Module TermConditionMap OpDeclSet -> SimpleCritPairSet .
  op getSimpleCritPairs : Module TermConditionMap EqFamilyMap -> SimpleCritPairSet .
  ----------------------------------------------------------------------------------
  eq getSimpleCritPairs(M)         = getSimpleCritPairs(M,empty) .
  eq getSimpleCritPairs(M,TCM)     = getSimpleCritPairs(M,TCM,getEqFamilies(M)) .
  eq getSimpleCritPairs(M,TCM,ODS) = getSimpleCritPairs(M,TCM,getEqFamilies(M,getEqFamilies(M),ODS)) .
 ceq getSimpleCritPairs(M,TCM,EFM) = scps(M, TCM, EFM, .SimpleCritPairSet) if wellFormed(M,TCM) .

  op scps : Module TermConditionMap EqFamilyMap SimpleCritPairSet -> SimpleCritPairSet .
  op scps : Module TermConditionMap QidList EqPairSet EqFamilyMap SimpleCritPairSet -> SimpleCritPairSet .
  op scps : Module TermConditionMap QidList SubstitutionPairSet EquationPair EqPairSet EqFamilyMap SimpleCritPairSet -> SimpleCritPairSet .
  -----------------------------------------------------------------------------------------------------------------------------------------
  eq scps(M,TCM,((Q,TL) |-> ES) EFM, CPS) = scps(M,TCM,Q TL,getEqPairs(ES),EFM,CPS) .
  eq scps(M,TCM, nil,                CPS) = CPS .

  eq scps(M,TCM,QL,(E,E') | EPS, EFM, CPS) = scps(M,TCM,QL,disjUnifiers(M,false,lhs(E),lhs(E')), (E,E'), EPS, EFM, CPS) .
  eq scps(M,TCM,QL,.EqPairSet,   EFM, CPS) = scps(M,TCM,EFM,CPS) .

  eq scps(M,TCM,QL,(S,S') | SPS,(E,E'),EPS,EFM,CPS) = scps(M,TCM,QL,SPS,(E,E'),EPS,EFM,CPS scp(M,TCM,QL,E,E',S,S')) .
  eq scps(M,TCM,QL,empty,       (E,E'),EPS,EFM,CPS) = scps(M,TCM,QL,EPS,EFM,CPS) .

  --- immediately check if equation instance violates assumption and toss if it does
  op scp : Module TermConditionMap QidList Equation Equation Substitution Substitution ~> SimpleCritPairSet .
  -----------------------------------------------------------------------------------------------------------
  eq scp(M,TCM,QL,E,E',S,S') =
    if preunfeasible(M,simpCond(M,getCond(M,lhs(E) << S,TCM),nil))
     then .SimpleCritPairSet
     else cp(QL,ctp(rhs(E) << S,rhs(E') << S'),(cond(E) << S) /\ (cond(E') << S'),getCond(M,lhs(E) << S,TCM))
    fi .

  op getCond : Module Term TermConditionMap -> EqCondition .
  op getCond : Module Term Substitution? EqCondition TermConditionMap -> EqCondition .
  ------------------------------------------------------------------------------------
  eq getCond(M,T1,(T2 |-> C,TCM)) = getCond(M,T1,metaMatch(M,T2,T1),C,TCM) .
  eq getCond(M,T1,empty)          = nil .

  eq getCond(M,T1,noMatch,C,TCM) = getCond(M,T1,TCM) .
  eq getCond(M,T1,S,      C,TCM) = C << S .

  op simpCond : Module EqCondition EqCondition ~> EqCondition .
  -------------------------------------------------------------
  eq simpCond(M,T1 = T2 /\ C, C') = simpCond(M,C,C' /\ metaReduce2(M,T1) = metaReduce2(M,T2)) .
  eq simpCond(M,nil,          C') = C' .

  op simplify : Module SimpleCritPairSet -> SimpleCritPairSet .
  op simplify : Module SimpleCritPairSet SimpleCritPairSet -> SimpleCritPairSet .
  -------------------------------------------------------------------------------
  eq simplify(M,CPS)                            = simplify(M,CPS,.SimpleCritPairSet) .

  eq simplify(M,cp(QL,ctp(T1,T2),C,A) CPS,CPS') = simplify(M,CPS,CPS' equalOrDelete(cp(QL,ctp(metaReduce2(M,T1),metaReduce2(M,T2)),C,A))) .
  eq simplify(M,.SimpleCritPairSet,CPS')        = CPS' .

  op subsume  : Module SimpleCritPairSet -> SimpleCritPairSet .
  op subsume  : Module SimpleCritPairSet SimpleCritPairSet -> SimpleCritPairSet .
  op subsume2 : Module SimpleCritPair SimpleCritPairSet SimpleCritPairSet -> SimpleCritPairSet .
  ----------------------------------------------------------------------------------------------
  eq subsume(M,CPS) = subsume(M,CPS,.SimpleCritPairSet) .

  eq subsume(M,CP CPS,CPS') = subsume(M,CPS,subsume2(M,CP,CPS',.SimpleCritPairSet)) .
  eq subsume(M,.SimpleCritPairSet,CPS') = CPS' .

  eq subsume2(M,CP,CP' CPS',CPS) =
    if cp-matches?(M,CP,CP') --- CP >= CP', so delete CP'
      then subsume2(M,CP,CPS',CPS)
      else if cp-matches?(M,CP',CP) --- CP' >= CP, so delete CP and skip redundant work
        then CP' CPS' CPS
        else subsume2(M,CP,CPS',CP' CPS) --- neither CP >= CP' nor CP' >= CP, so keep both
      fi
    fi .
  eq subsume2(M,CP,.SimpleCritPairSet,CPS) = CP CPS .

  --- miscellaneous utility functions
  -----------------------------------
  op equalOrDelete : SimpleCritPair -> SimpleCritPairSet .
  eq equalOrDelete(cp(QL,ctp(T1,T2),C,A)) = if T1 == T2 then .SimpleCritPairSet else cp(QL,ctp(T1,T2),C,A) fi .

  op cp-matches? : Module SimpleCritPair SimpleCritPair -> Bool .
  eq cp-matches?(M,CP,CP') = getOpId(CP) == getOpId(CP') and-then matches?(eqset-pair-func(M),scpToTerm(M,CP),scpToTerm(M,CP')) .

  op scpToTerm : Module SimpleCritPair ~> Term .
  eq scpToTerm(M,cp(QL,ctp(T1,T2),C,A)) = toEqSetPairTerm(M,eq T1 = T2 [none].,eqCondToEqs(C)) .

  op toStdCritPairs : SimpleCritPairSet -> CritPairSet .
  op toStdCritPairs : SimpleCritPairSet CritPairSet -> CritPairSet .
  ------------------------------------------------------------------
  eq toStdCritPairs(CPS) = toStdCritPairs(CPS,none) .
  eq toStdCritPairs(cp(Q QL,ctp(T1,T2),C,A) CPS, OCPS) =
    toStdCritPairs(CPS, OCPS if (C /\ A) == nil
      then  cp(string(Q),qid(""),qid(""),T1,T2,       pending)
      else ccp(string(Q),qid(""),qid(""),T1,T2,C /\ A,pending)
    fi) .
  eq toStdCritPairs(.SimpleCritPairSet, OCPS) = OCPS .

  op renameCPs : SimpleCritPairSet -> SimpleCritPairSet .
  op renameCPs : SimpleCritPairSet SimpleCritPairSet -> SimpleCritPairSet .
  -------------------------------------------------------------------------
  eq renameCPs(CPS) = renameCPs(CPS, .SimpleCritPairSet) .

  eq renameCPs(CP CPS,            CPS') = renameCPs(CPS, CPS' renameCP(CP)) .
  eq renameCPs(.SimpleCritPairSet,CPS') = CPS' .

  op renameCP : SimpleCritPair ~> SimpleCritPair .
  ------------------------------------------------
 ceq renameCP(cp(QL,ctp(T1,T2),C,A)) = cp(QL,ctp(T1',T2'),C',A')
  if [D ,(T1',T2')] := #renameVars(nullNameData,(T1,T2))
  /\ [D1,C']        := #renameCond(D, C)
  /\ [D2,A']        := #renameCond(D1,A) .

  op wellFormed : Module TermConditionMap -> Bool .
  -------------------------------------------------
  eq wellFormed(M,(T1 |-> C, TCM)) = vars(flatten(C)) subset vars(T1) and-then wellFormedSet(M,TermSet((T1,flatten(C)))) and-then wellFormed(M,TCM) .
  eq wellFormed(M,(empty).TermConditionMap) = true .

  op flatten : EqCondition ~> TermList .
  --------------------------------------
  eq flatten(T1 = T2 /\ C) = T1,T2,flatten(C) .
  eq flatten(nil)          = empty .
endfm

fmod TRANSFORM-CRITPAIR is
  pr SIMPLE-CRITPAIR .
  pr VAR-UNIF-PARTIAL-FVP .
  pr ABSTRACT-RULES .

  var M    : Module .
  var SL   : SLCStrategyList .
  var SCS  : TermSLCCommandPairSet .
  var XCS  : SubstitutionSLCCommandPairSet .
  var CP   : CritPair .
  var CPS  : CritPairSet .
  var CMD  : SLCCommand .
  var U V  : Term .
  var S S' : Substitution .
  var SS   : SubstitutionSet .
  var St   : String .
  var L L' : Qid .
  var T T' : Term .
  var Cd   : Condition .
  var CPSt : CPStatus .
  var C C' : EqCondition .
  var PC   : PosConj? .
  var FSS  : FOFormSubstPairSet .

  sort SLCStrategy SLCStrategyList .
  subsort SLCStrategy < SLCStrategyList .
  op {_} : SLCCommand -> SLCStrategy [ctor] .
  op __  : SLCStrategyList SLCStrategyList -> SLCStrategyList [ctor assoc id: nil] .
  op nil : -> SLCStrategyList [ctor] .

  sort SLCCommand .
  op skip : -> SLCCommand [ctor] .
  op split-cover : Term TermSLCCommandPairSet -> SLCCommand [ctor] .
  op case : SubstitutionSLCCommandPairSet -> SLCCommand [ctor] .

  sort TermSLCCommandPair TermSLCCommandPairSet .
  subsort TermSLCCommandPair < TermSLCCommandPairSet .
  op (_:_) : Term SLCCommand -> TermSLCCommandPair [ctor] .
  op __    : TermSLCCommandPairSet TermSLCCommandPairSet -> TermSLCCommandPairSet [ctor assoc comm id: none] .
  op none  : -> TermSLCCommandPairSet .

  sort SubstitutionSLCCommandPair SubstitutionSLCCommandPairSet .
  subsort SubstitutionSLCCommandPair < SubstitutionSLCCommandPairSet .
  op (_:_) : Substitution SLCCommand -> SubstitutionSLCCommandPair [ctor] .
  op __    : SubstitutionSLCCommandPairSet SubstitutionSLCCommandPairSet -> SubstitutionSLCCommandPairSet [ctor assoc comm id: none] .
  op none  : -> SubstitutionSLCCommandPairSet .

  op transform : CritPairSet SLCStrategyList -> CritPairSet .
  -----------------------------------------------------------
  eq transform(CP CPS,{ CMD } SL) = transform(CP,CMD) transform(CPS,SL) .
  eq transform(none,          SL) = none .
  eq transform(CPS,          nil) = CPS .

  op transform : CritPair SLCCommand -> CritPair .
  ------------------------------------------------
  eq transform(CP,skip)                         = CP .

  eq transform(CP,split-cover(U,(V : CMD) SCS)) = transform(split(CP,U,V),CMD) transform(CP,split-cover(U,SCS)) .
  eq transform(CP,split-cover(U,         none)) = none .

  eq transform(CP,case((S : CMD) XCS)) = transform(CP << S,CMD) transform(CP,case(XCS)) .
  eq transform(CP,case(         none)) = none .

  op simpCP : Module CritPairSet -> CritPairSet .
  -----------------------------------------------
  eq simpCP(M,CP CPS) = simpCP(M,CP,cond(CP),nil,none) simpCP(M,CPS) .
  eq simpCP(M,none)   = none .

  op simpCP : Module CritPair EqCondition EqCondition Substitution ~> CritPair .
  ------------------------------------------------------------------------------
  eq simpCP(M,CP,T = T' /\ C, C',S) =
    if T :: Variable and sortLeq(M,leastSort(M,T'),leastSort(M,T))
      then simpCP(M,CP,C,C',                                        S ; T <- T')
      else simpCP(M,CP,C,C' /\ metaReduce2(M,T) = metaReduce2(M,T'),S          )
    fi .
  eq simpCP(M,CP,nil,C',S) = setCond(CP,C') << S .

  op partialVarUnif  : Module CritPairSet -> CritPairSet .
  op partialVarUnif1 : CritPair FOFormSubstPairSet -> CritPairSet .
  ----------------------------------------------------------------
  eq partialVarUnif(M,CP CPS) =
    partialVarUnif1(CP,dbgPrintVarUnifSimp(false,cond(CP),#varunif-simp(M,eqCond2PosConj(cond(CP),mtForm))))
    partialVarUnif (M,CPS) .
  eq partialVarUnif(M,none) = none .

  eq partialVarUnif1(CP,(PC,S) | FSS) = (setCond(CP,posConj2EqCond(PC)) << S) partialVarUnif1(CP,FSS) .
  eq partialVarUnif1(CP,mtFSPS)       = none .

  op dbgPrintVarUnifSimp : Bool EqCondition FOFormSubstPairSet -> FOFormSubstPairSet .
  -----------------------------------------------------------------------------
  eq dbgPrintVarUnifSimp(true, C,FSS) = FSS [print "For Condition: " C " Forms: " FSS] .
  eq dbgPrintVarUnifSimp(false,C,FSS) = FSS .

  op _<<_ : CritPair SubstitutionSet -> CritPairSet .
  ---------------------------------------------------
  eq CP << (S | S' | SS) = (CP << S) (CP << (S' | SS)) .
  eq CP << empty         = none .

  eq  cp(    L, L', T, T',     CPSt) << S =   cp(    L, L', T << S, T' << S,          CPSt) .
  eq ccp(    L, L', T, T', Cd, CPSt) << S =  ccp(    L, L', T << S, T' << S, Cd << S, CPSt) .
  eq  cp(St, L, L', T, T',     CPSt) << S =   cp(St, L, L', T << S, T' << S,          CPSt) .
  eq ccp(St, L, L', T, T', Cd, CPSt) << S =  ccp(St, L, L', T << S, T' << S, Cd << S, CPSt) .

  op posConj2EqCond : PosConj? -> EqCondition .
  ---------------------------------------------
  eq posConj2EqCond(T ?= T' /\ PC) = T = T' /\ posConj2EqCond(PC) .
  eq posConj2EqCond(mtForm)        = nil .
endfm

mod CONFLUENCE-TOOLS is
  pr UNIT-FM .
  pr REMOVE-IDS .
  pr CONFLUENCE-CHECK .
  pr SIMPLE-CRITPAIR .
  pr TRANSFORM-CRITPAIR .

  var VS : QidSet .
  var S : Sort .
  var M M' M'' : Module .
  var QIL QIL' : QidList .
  var V : Variable .
  var TS : TermSet .
  var T : Term .
  var TL : TermList .
  var ODS : OpDeclSet .
  var Eq : Equation .
  var EqS : EquationSet .
  var Rl : Rule .
  var RlS : RuleSet .
  var MbS : MembAxSet .
  var Ct : Constant .
  var QI QI' F L L' : Qid .
  var Vb : Variable .
  var Tp Tp' : Type .
  var TpL : TypeList .
  var AtS : AttrSet .
  var N : Nat .
  var Cd : Condition .
  var NL : NatList .
  var B B' B'' : Bool .
  var Id Id' : String .

  op $prepareModule : Module Bool -> Module .
  eq $prepareModule(M, true) = $prepareModule(freezeNonCtors(M), false) .
  eq $prepareModule(M, false) = removeIds(M, all) .

  op freezeNonCtors : Module -> Module .
  op $freezeNonCtors : OpDeclSet -> OpDeclSet .
  op $frozenPositions : NeTypeList -> NeNatList .
  op $frozenPositions : TypeList Nat -> NatList .

  eq freezeNonCtors(M) = setOps(M, $freezeNonCtors(getOps(M))) .
  eq $freezeNonCtors(op F : TpL -> Tp [ctor AtS] . ODS)
    = op F : TpL -> Tp [ctor AtS] . $freezeNonCtors(ODS) .
  eq $freezeNonCtors(op F : TpL -> Tp [frozen(NL) AtS] . ODS)
    = op F : TpL -> Tp [frozen(NL) AtS] . $freezeNonCtors(ODS) .
  eq $freezeNonCtors(op F : TpL -> Tp [AtS] . ODS)
    = op F : TpL -> Tp [if $frozenPositions(TpL) =/= nil then frozen($frozenPositions(TpL)) else none fi AtS] . $freezeNonCtors(ODS) [owise] .
  eq $freezeNonCtors(none) = none .

  eq $frozenPositions(TpL) = $frozenPositions(TpL, 1) .
  eq $frozenPositions(Tp TpL, N) = N $frozenPositions(TpL, s N) .
  eq $frozenPositions(nil, N) = nil .

  sort CoveredCaseError CoveredCaseResult .
  subsort CoveredCaseError < CoveredCaseResult .
  op ok : -> CoveredCaseResult [ctor] .
  op errorMsg : QidList -> CoveredCaseError [ctor] .
  op noncoherent : Module QidList -> CoveredCaseError [ctor] .
  op unsupported : String -> CoveredCaseError [ctor] .

  op coveredCase : Module -> CoveredCaseResult .
  eq coveredCase(M)
    = if anyAttrOccurs?(special-attr owise idem iter,getOps(M))
      then unsupported("The use of built-ins/owise/idem/iter is not supported by the checker.")
      else if anyLhsIsVar?(getRls(M))
           then unsupported("The module has rules with single variables in their left-hand sides.")
           else if anyLhsIsVar?(getEqs(M))
                then unsupported("The module has equations with single variables in their left-hand sides.")
                else if not order-sorted(M)
                     then unsupported("The checker only covers the order-sorted case.")
                     else ok
                     fi
                fi
           fi
      fi .

  op order-sorted : Module -> Bool .
  op order-sorted : EquationSet -> Bool .
  op order-sorted : RuleSet -> Bool .
  op order-sorted : Condition -> Bool .
  eq order-sorted(M)
    = getMbs(M) == none and-then order-sorted(getEqs(M)) and-then order-sorted(getRls(M)) .
  eq order-sorted(Eq EqS) = order-sorted(cond(Eq)) and-then order-sorted(EqS) .
  eq order-sorted((none).EquationSet) = true .
  eq order-sorted(Rl RlS) = order-sorted(cond(Rl)) and-then order-sorted(RlS) .
  eq order-sorted((none).RuleSet) = true .
  eq order-sorted(T : S /\ Cd) = false .
  eq order-sorted(Cd) = true [owise] .
endm
